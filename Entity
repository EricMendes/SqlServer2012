using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary
{
    public class Client
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public Gender Gender { get; set; }
        public DateTime BirthDate { get; set; }
    }

    public enum Gender
    {
        Male = 1,
        Female = 2
    }
}

using System;
using System.Collections.Generic;
using System.Linq;

namespace ClassLibrary
{
    public interface ITask
    {
        string Execute(string payload);
    }

    public interface IPropertyCustomizable
    {
        IEnumerable<TaskProperty> GetCustomProperties();
        void SetCustomProperty(string propertyName, string propertyValue);
    }

    public interface IValidated
    {
        IEnumerable<string> ValidationErrors { get; }
        bool IsValid();
    }

    public abstract class Task : ITask
    {
        public int Id { get; protected set; }
        public string Name { get; protected set; }
        public string Description { get; protected set; }
        public TaskType Type { get; protected set; }
        public TaskStatus Status { get; protected set; }
        public string In { get; private set; }
        public string Out { get; private set; }
        public string Execute(string payload)
        {
            var retorno = string.Empty;
            Status = TaskStatus.Started;
            In = payload;
            OnExecuteStart?.Invoke(this, EventArgs.Empty);
            retorno = ExecuteTask(payload);
            Out = retorno;
            OnExecuteFinish?.Invoke(this, EventArgs.Empty);
            Status = TaskStatus.Success;
            return retorno;
        }

        public event ExecuteStartEventHandler OnExecuteStart;
        public event ExecuteFinishEventHandler OnExecuteFinish;
        
        protected abstract string ExecuteTask(string payload);
    }

    public class TaskExecutionEventArgs: EventArgs
    {
        public TaskStatus Status { get; set; }
    }

    public delegate void ExecuteStartEventHandler(object sender, EventArgs e);
    public delegate void ExecuteFinishEventHandler(object sender, EventArgs e);

    public enum TaskStatus
    {
        Started = 1,
        Success = 2,
        Failed = 3
    }

    public class MandatoryFieldMissingException: ApplicationException
    {
        public MandatoryFieldMissingException(string message): base(message)
        {

        }
    }

}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary
{
    public class Page<T>: List<T>
    {
        public int TotalPages { get; set; }
        public int CurrentPage { get; set; }
        public int RegistersPerPage { get; set; }
        public int TotalRegisters { get; set; }
    }

    public interface IRepositoryBase<T> where T : class
    {
        void Save(T entity);
        T GetById(int id);
        IEnumerable<T> GetAll();
        IEnumerable<T> GetAll(Func<T, bool> filters);

    }

    public interface IPagedRepositoryBase<T>: IRepositoryBase<T> where T : class 
    {
        Page<T> GetPage(Func<T, bool> filters, int pageNumber, int recordsPerPage, Func<IEnumerable<T>, IEnumerable<T>> order);
    }

    public class RepositoryBase<T> : IRepositoryBase<T> where T : class
    {
        public IEnumerable<T> GetAll()
        {
            throw new NotImplementedException();
        }

        public IEnumerable<T> GetAll(Func<T, bool> filters)
        {
            throw new NotImplementedException();
        }

        public T GetById(int id)
        {
            throw new NotImplementedException();
        }

        public void Save(T entity)
        {
            throw new NotImplementedException();
        }
    }


    public class PagedRepositoryBase<T> : RepositoryBase<T>, IPagedRepositoryBase<T> where T : class
    {
        public Page<T> GetPage(Func<T, bool> filters, int pageNumber, int recordsPerPage, Func<IEnumerable<T>, IEnumerable<T>> order)
        {
            var entities = ClientList.GetClientList()  as IEnumerable<T>;//Substituir pela consulta no EF

            var skip = (pageNumber - 1) * recordsPerPage;
            var totalCount = entities.Count();
            double totalPages = Math.Ceiling(totalCount / (double)recordsPerPage);
            entities = entities.Where(filters);
            if (order != null)
            {
                entities = order(entities);
            }
            entities = entities.Skip(skip).Take(recordsPerPage);

            Page<T> pagedEntity = new Page<T>();
            pagedEntity.AddRange(entities);
            pagedEntity.TotalPages = Convert.ToInt32(totalPages);
            pagedEntity.TotalRegisters = totalCount;
            pagedEntity.CurrentPage = pageNumber;
            pagedEntity.RegistersPerPage = recordsPerPage;

            return pagedEntity;
        }
    }

    public static class ClientList 
    {
        public static List<Client> GetClientList()
        {
            var clientlist = new List<Client>();

            clientlist.Add(new Client()
            {
                Id = 1,
                Name = "Eric Mendes de Souza",
                Gender = Gender.Male,
                BirthDate = new DateTime(1981, 2, 9)
            });
            clientlist.Add(new Client()
            {
                Id = 2,
                Name = "Lilian Castro Kelian",
                Gender = Gender.Female,
                BirthDate = new DateTime(1986, 4, 24)
            });
            clientlist.Add(new Client()
            {
                Id = 3,
                Name = "Maria Luiza Carvalho Mendes",
                Gender = Gender.Female,
                BirthDate = new DateTime(2012, 1, 4)
            });
            clientlist.Add(new Client()
            {
                Id = 4,
                Name = "Cauã Kelian Kulaif",
                Gender = Gender.Male,
                BirthDate = new DateTime(2004, 10, 31)
            });
            clientlist.Add(new Client()
            {
                Id = 5,
                Name = "André Kelian Kulaif",
                Gender = Gender.Male,
                BirthDate = new DateTime(2007, 5, 15)
            });

            return clientlist;
        }
    }

    public class ClientRepository : PagedRepositoryBase<Client>
    {
        
    }
}



using System;

namespace ClassLibrary
{
    public class TaskProperty
    {
        public string Name { get; set; }
        public string Type { get; set; }
        public bool IsMandatory { get; set; }
    }

    public enum PropertyType
    {
        String = 1,
        Int = 2,
        Double = 3,
        Boolean = 4
    }

    public class PropertyConverter
    {

    }
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary
{
    public class TaskType
    {
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary
{
    public class TxtSourceTask : Task, IPropertyCustomizable, IValidated
    {
        public char? Separator { get; private set; }
        private bool HasHeader { get; set; }
        public List<TaskProperty> CustomProperties { get; set; }
        public IEnumerable<string> ValidationErrors { get { return validationErrors; } }
        private List<string> validationErrors { get; set; }
        public TxtSourceTask()
        {
            validationErrors = new List<string>();
            CustomProperties = new List<TaskProperty>();
            InitializeCustomProperties();
        }

        private void InitializeCustomProperties()
        {
            var separator = new TaskProperty()
            {
                Name = "Separator",
                IsMandatory = true,
                Type = "char"
            };
            CustomProperties.Add(separator);

            var hasValue = new TaskProperty()
            {
                Name = "HasValue",
                IsMandatory = false,
                Type = "bool"
            };
            CustomProperties.Add(hasValue);
        }

        public bool IsValid()
        {
            validationErrors.Clear();
            bool isValid = false;
            if (Separator == null)
            {
                validationErrors.Add("Separator não está definido.");
            }
            else
            {
                isValid = true;
            }
            return isValid;
        }

        protected override string ExecuteTask(string payload)
        {
            if (IsValid())
            {
                return payload.Replace(Separator.Value, ';');
            }
            else
            {
                throw new MandatoryFieldMissingException("Uma ou mais propriedades obrigatórias não foram preenchidas. Analise a propriedade ValidationErrors para mais detalhes.");
            }
        }

        public IEnumerable<TaskProperty> GetCustomProperties()
        {
            return CustomProperties;
        }

        public void SetCustomProperty(string propertyName, string propertyValue)
        {
            switch (propertyName.ToLower())
            {
                case "separator":
                    char separator;
                    Char.TryParse(propertyValue, out separator);
                    Separator = separator;
                    break;
                case "hasheader":
                    bool hasheader;
                    bool.TryParse(propertyValue, out hasheader);
                    HasHeader = hasheader;
                    break;
                default:
                    throw new Exception("Propriedade não encontrada.");
            }
        }
    }
}
using ClassLibrary;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();
            TxtSourceTask txtSourceTask = new TxtSourceTask();
            var properties = txtSourceTask.GetCustomProperties();
            foreach (var item in properties)
            {
                Console.WriteLine("Name:{0}, Type:{1}, IsMandatory:{2}.", item.Name, item.Type, item.IsMandatory);
            }

            string valueToConvert = "Eric,M,36";
            txtSourceTask.SetCustomProperty("separator", ",");
            string retorno = txtSourceTask.Execute(valueToConvert);
            sw.Stop();

            Console.WriteLine(sw.Elapsed);
            Console.WriteLine(retorno);

            //ClientRepository repository = new ClientRepository();
            //var clients = repository.GetPage(c => c.Id < 10, 1, 5, x => x.OrderBy(c => c.Gender).ThenBy(c => c.BirthDate));
            //foreach (var item in clients)
            //{
            //    Console.WriteLine("Cliente {0}, Nome: {1}, Sexo: {2}, Nascimento: {3}.", item.Id, item.Name, item.Gender, item.BirthDate);
            //}
            //Console.WriteLine("Página {0} de {1}. Mostrando {2} registros de um total de {3}", clients.CurrentPage, clients.TotalPages, clients.RegistersPerPage, clients.TotalRegisters);

            Console.ReadKey();
        }
    }
}

De acordo com pesquisas, dados médicos apenas dos EUA vão além de 150 exabytes em 2011 e tem potencial de ir além, para zettabytes (1021 bytes) e yottabytes

(1024 gigabytes). A análise dos dados se torna o gargalo por causa dessa magnitude. Portanto, especialistas no domínio de cuidados médicos estão olhando para 

a ciência da computação investigar e chegar a
às soluções para transformar dados em informação e conhecimento. 

Técnicas e Ferramentas para análise de dados de assistência médica


O domínio de informações de assitência médica é rico mas necessita ser transformado em conhecimento. As ferramentas e 
técnicas efetivas são formuladas para descobrir relações e tendências escondidas. Kavakiotis cita uma sistemática e detalhada 
revisão na aplicação de técnicas de mineração de dados e machine learning para realizar análise da diabete mellitus para 
predição e diagnóstico, achando associações complicadas com isso e com a herança genética e ambiente para conseguir melhoras 
na assistência médica. Existem várias técnicas de mineração de dados sendo usadas na indústria da saúde para várias doenças 
usando métodos de classificação que foram demonstrados em vários estudos de caso de sucesso, eles são na maioria rule-based, 
rede neural artificial e árvores de decisão.
A arquitetura segura para análise de big data é regulada pela CSA (Cloud Secure Alliance). Quando usada na assistência médica, EHR se torna o conjunto de 

dados de entrada para uma plataforma de analytics tendo HDFS com FLUME e SQOOP como a camada de dados. MapReduce e HIVE fazem a análise dos dados usando 

algoritmos de machine learning. STORM é uma ferramenta de streaming usada para qualquer emergência chegando e intimando toda a equipe de saúde em questão 

imediatamente através da função do AWS Lambda. Intellicius and hunk produzem os relatórios.

Benefícios das técnicas de mineração de dados no setor de saúde:

- Modelagem de dados com segurança para sistemas de saúde.
- Formulação do custo do tratamento e disponibilidade de recursos, conforme necessário.
- Previsão comportamental futura baseada na história do paciente.
- Elaboração de sistema executivo de informação em saúde.
- Informática em saúde pública.
- Implementando estruturas de e-governance nos cuidados médicos.
- Plano de saúde

-Gerenciamento do usuário.
-Gerenciamento de coleção.
-Gerenciamento de wishlist.
-Sugestão de trocas.
-Avaliação de usuários com quem você trocou.
-Avaliação de jogos.

Organizações da saúde podem implementar KDD (Knowledge Discovery in Databases) usando frameworks definidos em [***] com a ajuda de recursos qualificados que 

estão bem familiarizado com o jargão médico coletado através de diferentes fontes.
Machine Learning e Data Mining se sobrepõem em alguns pontos durante a classificação. A mineração de dados está percebendo as informações anteriormente 

desconhecidas onde irmão que é aprendizado de máquina é conhecido desde a década de 1960 e se concentra na classificação e previsão. Algoritmos de 

aprendizado de máquina avaliam ou predizem resultados com base em
informação previamente conhecida utilizando-a como um conjunto de treinamento.
 
Existem muitas questões sobre avaliação clínica de pacientes que pode ser respondida com base na relação encontrada pela análise de milhões de pacientes 

registros armazenados no KDD. 
Perguntas podem ser tais como:

- Com base nos sintomas do paciente, quais testes devem ser recomendados para diagnóstico?
- Se esses problemas relacionados à saúde ocorrem, então qual possível doença é mais possível?
- Quais são os sintomas mais comuns encontrados em pacientes diabéticos?
- Qual é a faixa etária dos pacientes com doença cardíaca?
- O faturamento padrão para um diagnóstico específico é quanto?


Técnicas de classificação e agrupamento
